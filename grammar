// This grammar parses programs under the assumption
// that trailing whitespaces have been removed, and
// sequences of two or more whitespaces have been
// substituted by a single whitespace, so input strings
// must be preprocessed before being handed to the parser.

// Flat, simple rules where preferred over equivalent but
// more elegant recursive formulations to avoid nesting
// and simplify handling parser output.

start : NEWLINE* ((sort | comment) NEWLINE*)+ ((rule | assertion | comment | disjunction) NEWLINE*)+ NEWLINE*

comment : "--" (LETTER | WS | NEWLINE | INT | "/"
        | "," | ":" | "." | "(" | ")" | "'" | "?" | "!")* "--" NEWLINE

sort : "sort" WS token WS INT NEWLINE
     | "sort" WS token WS "add" WS (token "," WS)* token NEWLINE

rule : atoms (WS | NEWLINE) "=>" (WS | NEWLINE) atoms
     | atoms (WS | NEWLINE) "=>" (WS | NEWLINE) "False"

assertion : atoms

disjunction : atom ((WS | NEWLINE) vee (WS | NEWLINE) atom)+

vee : "v"

atoms : atom
      | (atom "," (WS | NEWLINE))* atom

atom : term "(" (term "," WS)* term ")"
     | term WS term WS term

term : token
     | (token WS* "." WS*)+ token

token : (WORD WS*)+

WORD: LETTER+ | ":" | "=" | "!="

%import common.LETTER
%import common.WS
%import common.NEWLINE
%import common.INT
