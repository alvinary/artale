// This grammar parses programs under the assumption
// that trailing whitespaces have been removed, and
// sequences of two or more whitespaces have been
// substituted by a single whitespace, so input strings
// must be preprocessed before being handed to the parser.

// Flat, simple rules where preferred over equivalent but
// more elegant recursive formulations to avoid nesting
// and simplify handling parser output.

start : NEWLINE* ((sort | comment) NEWLINE*)+ ((rule | assertion | comment | disjunction) NEWLINE*)+ NEWLINE*

comment : "--" (LETTER | WS | NEWLINE | INT | "/" | "=" | 
        | "," | ":" | "." | "(" | ")" | "'" | "?" | "!" |
        | "<" | ">" | "-")* "--" NEWLINE

sort : "sort" WS sortoken WS INT
     | "sort" WS sortoken WS "add" WS (sortoken "," WS)* sortoken

rule : atoms (WS | NEWLINE) "=>" (WS | NEWLINE) atoms
     | atoms (WS | NEWLINE) "=>" (WS | NEWLINE) "False"

assertion : atoms

disjunction : atom ((WS | NEWLINE) vee (WS | NEWLINE) atom)+

vee : "v"

atoms : atom
      | (atom "," (WS | NEWLINE))* atom

atom : term "(" (term "," WS)* term ")"
     | term WS term WS term

term : token
     | (token WS* "." WS*)+ token

token : (WORD WS*)+

WORD: (LETTER | INT)+ | ":" | "=" | "!="

sortoken : LETTER (LETTER | WS)*

%import common.LETTER
%import common.WS
%import common.NEWLINE
%import common.INT
