sort node 13
sort type 30

left (n : node, m : node) v not left (n, m)
left (n : node, m : node), not left (n, m) => False

right (n : node, m : node) v not right (n : node, m : node)
right (n : node, m : node), not right (n, m) => False

leaf (n : node) v phrase (n)
leaf (n : node), phrase (n) => False

leaf (n : node), left (n, m : node) => False
leaf (n : node), right (n, m : node) => False

phrase (n : node), next (n : node, m : node) => left (n, m)

left (n : node, n) => False
right (n : node, n) => False

left (a : node, b : node), right (a, b) => False

left (n : node, m : node), before (m, n) => False
right (n : node, m : node), before (m, n) => False

left (n : node, m : node) => next (n, m)
left (a : node, b : node), right(a, c : node), leaf (b) => next(b, c)

left of (b : node, a : node), before (a, b) => False
left (a : node, b : node), right (a, c : node) => left of (b, c)
left of (a : node, b : node), left of (b : node, c : node) => left of (a, c)
left of (a : node, b : node), left of (b, a) => False

left (a : node, b : node), right (a, b) => False

phrase (a : node), not left (a, any : node) => False
phrase (a : node), not right (a, any : node) => False

right (a : node, b : node), right (c : node, b), a != c => False
right (a : node, b : node), left (c : node, b) => False
left (a : node, b : node), left (c : node, b), a != c => False
left (a : node, b : node), right (c : node, b) => False

right (a : node, b : node), right (a, c : node), b != c => False
left (a : node, b : node), left (a, b : node), b != c => False

complement (t : type), adjunct (t) => False
complement (t : type) v adjunct (t)

not head (a : node, b : node) v head (a, b)
not head (a : node, b : node), head (a, b) => False

not head (a : node, b : node) v head (a, b)
not head (a : node, b : node), head (a, b) => False

head (a : node, b : node), head (a : node, c : node), b != c => False
left (a : node, b : node), right (a : node, c : node), not head (a, b), not head (a, c), b != c => False

right (a : node, b : node), head (a, b) => rightHeaded (a)
left (a : node, b : node), head (a, b) => leftHeaded (a)

not left (a : node, b : node), not right (a, b), child (a, b) => False

left (a : node, b : node) => child(a, b)
right (a : node, b : node) => child(a, b)

child(a : node, b : node), not left (a, b), not right(a, b) => False

-- Complementation and adjunction rules --

head (a : node, b : node), not child (a, b) => False

leftHeaded (a : node), right (a : node, b : node) => modifier (a, b)
rightHeaded (a : node), left (a : node, b : node) => modifier (a, b)

right head (b : node), right (a : node, b) => rightHeaded(a)
left head (b : node), left (a : node, b) => leftHeaded(a)

right modifier (b.type : node), right (a : node, b : node) => leftHeaded(a)
left modifier (b.type : node), left (a : node, b : node) => rightHeaded(a)

head (a : node, b : node), complement (b.type : node) => match (a.type, b.type.output)
head (a : node, b : node), modifier (a : node, c : node), complement (b.type) => match (a.type, b.type.input)

modifier (a : node, b : node), adjunct (b.type : node) => match (a.type, b.type.output)
head (a : node, b : node), modifier (a : node, c : node), adjunct (c.type) => match (a.type, b.type.input)

modifies to right (t : type) => adjunct (t : type)
modifies to left (t : type) => adjunct (t : type)

complements to left (t : type) => complement(t : type)
complements to right (t : type) => complement(t : type)

modifies to right (a.type : node), child (b : node, a : node) => left (b, a)
modifies to left (a.type : node), child (b : node, a : node) => right (b, a)

complements to right (a.type : node), child (b : node, a : node) => left (b, a)
complements to left (a.type : node), child (b : node, a : node) => right (b, a)

-- CCG-style typing rules --

sentential (t : type) v nominal (t : type)
sentential (t : type), nominal (t : type) => False

full (t : type) v blank (t : type)
full (t : type), blank (t) => False

nodetype (t : type) v not nodetype (t : type)
nodetype (t : type), not nodetype (t : type) => False

leaftype (t : type) v not leaftype (t : type)
leaftype (t : type), not leaftype (t : type) => False

nodetype (t : type), leaftype (t : type) => False
full (t : type), not leaftype (t : type), not nodetype (t : type) => False

leaftype (t : type) => blank (t.output), blank (t.input)

match (s : type, t : type) v not match (s, t)
match (s : type, t : type), not match(s, t) => False

match (s : type, t : type) => match (t, s)

blank (t : type), blank (s : type) => match (t, s)
leaftype (t : type), leaftype (s : type), nominal (t), nominal (s) => match (t, s)
leaftype (t : type), leaftype (s : type), sentential (t), sentential (s) => match (t, s)
nodetype (t : type), nodetype (s: type), match (t.input, s.input), match(t.output, s.output) => match (t, s)

leaftype (t : type), leaftype (s : type), nominal (t), sentential (s) => not match (t, s)
blank (t : type), full (s : type) => not match(t, s)

blank (t : type) => blank (t.output), blank (t.input)
nodetype (t : type), blank (t.input) => False
nodetype (t : type), blank (t.output) => False
nodetype (t : type) => full (t.input)
nodetype (t : type) => full (t.output)

phrase(a : node) => full(a.type)
leaf(a: node) => full(a.type)

blank (t: type), nodetype (t : type) => False
blank (t: type), leaftype (t : type) => False

--     You can cut a type node to prevent it from having meaningful branches --

cut (t : type) => blank(t.input), blank(t.output)

-- Lexical item rules --

--     If a word is a word node, it has to be a leaf --

word (a : node) => leaf (a)
word (a : node), phrase(a) => False

--     We define several common word types --
--     Common nouns, or n, are word nodes whose type is nominal and is cut --

n (a : node) => word(a), nominal (a.type), cut (a.type)

--     Common transitive verbs, or nns, are word nodes taking a noun as an input and returning --
--     a function from yet another noun to a sentence --

nns (a : node) => word(a)

nns (a : node) => nominal (a.type.input), nominal (a.type.output.input), sentential (a.type.output.output)
nns (a : node) => cut (a.type.input), cut (a.type.output.input), cut (a.type.output.output)

nns (a: node) => complements to right (a.type), complements to left (a.type.output)

--     Common noun adjuncts, or nn, are word nodes taking a noun as an argument and returning a noun --

nn (a : node) => word(a)

nn (a : node) => nominal (a.type.input), nominal (a.type.output)
nn (a : node) => cut (a.type.input), cut (a.type.output)

nn (a : node) => modifies to right (a.type)

-- es tio, esta tio, no, es silla, esta silla, no --
-- add blank semitems, if a semitem is blank, it cant have properties --

-- An individual expression is fully referring if it is identified --

-- An individual expression is identified if it has a relational determinant --

-- george 's uncle --
-- the man who sold the world --
-- peter is tall  --
-- peter is one of the tall folk --
-- peter is thomas 's boss --
-- thomas 's boss wants us to leave -- 

-- I dont trust the tall folk --

-- Poke peter --
-- Poke peter in the eye --
-- X Peter and Pam are poking --
-- Peter and Pam are looking --

chair (a : node) => n(a)
chair (a : node) => physical thing (a.drs.self)

broke (a : node) => nns(a)
broke (a : node) => actor (a.drs.1), thing (a.drs.2), event (a.drs.self)

steven (a : node) => n(a)
marygold (a : node) => n(a)

is (a : node) => word (a), nominal (a.type.input), nominal (a.type.output.input), sentential (a.type.output.output)
is (a : node) => cut (a.type.input), cut (a.type.output.input), cut (a.type.output.output)

the (a : node) => nn(a)
the (a : node) => cut (a.type.input), cut (a.type.output)
