sort node 30
sort type 30

left (n : node, m : node) v not left (n, m)
left (n : node, m : node), not left (n, m) => False

right (n : node, m : node) v not right (n, m)
right (n : node, m : node), not right (n, m) => False

leaf (n : node) v phrase (n)
leaf (n : node), phrase (n) => False

leaf (n : node), left (n, m : node) => False
leaf (n : node), right (n, m : node) => False

phrase (n : node), next (n : node, m : node) => left (n, m)

left (n : node, n) => False
right (n : node, n) => False

left (a : node, b : node), right (a, b) => False

left (n : node, m : node), before (m, n) => False
right (n : node, m : node), before (m, n) => False

left (n : node, m : node) => next (n, m)
left (a : node, b : node), right(a, c : node), leaf (b) => next(b, c)

left of (b : node, a : node), before (a, b) => False
left (a : node, b : node), right (a, c : node) => left of (b, c)
left of (a : node, b : node), left of (b : node, c : node) => left of (a, c)
left of (a : node, b : node), left of (b, a) => False

left (a : node, b : node), right (a, b) => False

phrase (a : node), not left (a, any : node) => False
phrase (a : node), not right (a, any : node) => False

right (a : node, b : node), right (c : node, b), a != c => False
right (a : node, b : node), left (c : node, b) => False
left (a : node, b : node), left (c : node, b), a != c => False
left (a : node, b : node), right (c : node, b) => False

right (a : node, b : node), right (a, c : node), b != c => False
left (a : node, b : node), left (a, b : node), b != c => False

complement (t : type), adjunct (t) => False
complement (t : type) v adjunct (t)

not head (a : node, b : node) v head (a, b)
not head (a : node, b : node), head (a, b) => False

not head (a : node, b : node) v head (a, b)
not head (a : node, b : node), head (a, b) => False

head (a : node, b : node), head (a : node, c : node), b != c => False
left (a : node, b : node), right (a : node, c : node), not head (a, b), not head (a, c), b != c => False

right (a : node, b : node), head (a, b) => rightHeaded (a)
left (a : node, b : node), head (a, b) => leftHeaded (a)

not left (a : node, b : node), not right (a, b), child (a, b) => False

left (a : node, b : node) => child(a, b)
right (a : node, b : node) => child(a, b)

child(a : node, b : node), not left (a, b), not right(a, b) => False

head (a : node, b : node), not child (a, b) => False

leftHeaded (a : node), right (a : node, b : node) => modifier (a, b)
rightHeaded (a : node), left (a : node, b : node) => modifier (a, b)

head (a : node, b : node), complement (b.type) => match (a.type, b.type.output)
head (a : node, b : node), modifier (a : node, c : node), complement (b.type) => match (a.type, b.type.input)

modifier (a : node, b : node), adjunct (b.type) => match (a.type, b.type.output)
head (a : node, b : node), modifier (a : node, c : node), adjunct (c.type) => match (a.type, b.type.input)

sentential (t : type) v nominal (t : type)
sentential (t : type), nominal (t : type) => False

full (t : type) v blank (t : type)
full (t : type), blank (t) => False

nodetype (t : type) v not nodetype (t)
nodetype (t : type), not nodetype (t) => False

leaftype (t : type) v not leaftype (t)
leaftype (t : type), not leaftype (t) => False

nodetype (t : type), leaftype (t) => False
full (t : type), not leaftype (t), not nodetype (t) => False

leaftype (t : type) => blank (t.output), blank (t.input)

match (s : type, t : type) v not match (s, t)
match (s : type, t : type), not match(s, t) => False

match (s : type, t : type) => match (t, s)

blank (t : type), blank (s : type) => match (t, s)
leaftype (t : type), leaftype (s : type), nominal (t), nominal (s) => match (t, s)
leaftype (t : type), leaftype (s : type), sentential (t), sentential (s) => match (t, s)
nodetype (t : type), nodetype (s: type), match (t.input, s.input), match(t.output, s.output) => match (t, s)

leaftype (t : type), leaftype (s : type), nominal (t), sentential (s) => not match (t, s)
blank (t : type), full (s : type) => not match(t, s)

blank (t : type) => blank (t.output), blank (t.input)
nodetype (t : type), blank (t.input) => False
nodetype (t : type), blank (t.output) => False
nodetype (t : type) => full (t.input)
nodetype (t : type) => full (t.output)

phrase(a : node) => full(a.type)
leaf(a: node) => full(a.type)

blank (a: type), nodetype (a) => False
blank (a: type), leaftype (a) => False

-- You can cut a type node to prevent it from having meaningful branches --
cut (t : type) => blank(t.input), blank(t.output)

-- If a word is a word node, it has to be a leaf --
word (a : node) => leaf (a)
word (a : node), phrase(a) => False

-- We define several common word types 

Common nouns, or ncom, are word nodes whose type is nominal and is cut

Common transitive verbs, or nns, are word nodes taking a noun as an input and returning 
a function from yet another noun to a sentence

Common noun adjuncts, or nn, are word nodes taking a noun as an argument and returning a noun --

is (a : node) => word (a), nominal (a.type.input), nominal (a.type.output.input), sentential (a.type.output.output)
is (a : node) => cut (a.type.input), cut (a.type.output.input), cut (a.type.output.output)

-- aprendi una banda en famaf en primero y segundo. A tercero y cuarto no los aproveche nada.
   salvo el primer cuatri, que programe banda, y el segundo en inge con los chicos.
   pero de teoria mucho no.

   Antes de haskell no entendia un pingo de recursion y no hubiera entendido CCG --

-- es tio, esta tio, no, es silla, esta silla, no --
-- add blank semitems, if a semitem is blank, it cant have properties --

the (a : node) => word (a), nominal (a.type.input), nominal (a.type.output)
the (a : node) => cut (a.type.input), cut (a.type.output)

-- An individual expression is fully referring if it is identified --

-- An individual expression is identified if it has a relational determinant --

ncom (a : node) => word(a), nominal (a.type), cut (a.type) 

george (a : node) => ncom(a), person (a.drs.self)
chair (a : node) => ncom(a), furniture (a.drs.self)

nn (a : node) => word(a)
nn (a : node) => nominal (a.type.input), nominal (a.type.output)
nn (a : node) => cut (a.type.input), cut (a.type.output)

nns (a : node) => word(a)
nns (a : node) => nominal (a.type.input), nominal (a.type.output.input), sentential (a.type.output.output)
nns (a : node) => cut (a.type.input), cut (a.type.output.input), cut (a.type.output.output)

broke (a : node) => actor (a.drs.1), thing (a.drs.2), event (a.drs.self)

-- george 's uncle --
-- the man who sold the world --
-- peter is tall  --
-- peter is one of the tall folk --
-- peter is thomas 's boss --
-- thomas 's boss wants us to leave -- 

-- I dont trust the tall folk --

-- Poke peter --
-- Poke peter in the eye --
-- X Peter and Pam are poking --
-- Peter and Pam are looking --

-- Ojala Elo pudiera ser orgullosa y tranquila como Santi de Famaf y Guido --
-- Tiene mucho miedo y la pasa re mal. Tiene un posdoctorado ya, ha trabajado bien, --
-- por un lado le sirve, pero si estuviera tranquila podria hacer mucho mas --

-- Y no se por que duda tanto del motor. Trickster Ne capaz --
