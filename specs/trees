sort node 30

left (n : node, m : node) v not left (n, m)
left (n : node, m : node), not left (n, m) => False

right (n : node, m : node) v not right (n, m)
right (n : node, m : node), not right (n, m) => False

leaf (n : node) v phrase (n)
leaf (n : node), phrase (n) => False

leaf (n : node), left (n, m : node) => False
leaf (n : node), right (n, m : node) => False

phrase (n : node), next (n : node, m : node) => left (n, m)

left (n : node, n) => False
right (n : node, n) => False

left (a : node, b : node), right (a, b) => False

left (n : node, m : node), before (m, n) => False
right (n : node, m : node), before (m, n) => False

left (n : node, m : node) => next (n, m)

left of (b : node, a : node), before (a, b) => False
left (a : node, b : node), right (a, c : node) => left of (b, c)
left of (a : node, b : node), left of (b : node, c : node) => left of (a, c)
left of (a : node, b : node), left of (b, a) => False

left (a : node, b : node), right (a, b) => False

phrase (a : node), not left (a, any : node) => False
phrase (a : node), not right (a, any : node) => False

right (a : node, b : node), right (c : node, b), a != c => False
right (a : node, b : node), left (c : node, b) => False
left (a : node, b : node), left (c : node, b), a != c => False
left (a : node, b : node), right (c : node, b) => False

right (a : node, b : node), right (a, c : node), b != c => False
left (a : node, b : node), left (a, b : node), b != c => False

complement (t : type), adjunct (t) => False
complement (t : type) v adjunct (t)

not head (a : node, b : node) v head (a, b)
not head (a : node, b : node), head (a, b) => False

not head (a : node, b : node) v head (a, b)
not head (a : node, b : node), head (a, b) => False

head (a : node, b : node), head (a : node, c : node), b != c => False
left (a : node, b : node), right (a : node, c : node), not head (a, b), not head (a, c), b != c => False

right (a : node, b : node), head (a, b) => rightHeaded (a)
left (a : node, b : node), head (a, b) => leftHeaded (a)

not left (a : node, b : node), not right (a, b), child (a, b) => False

left (a : node, b : node) => child(a, b)
right (a : node, b : node) => child(a, b)

child(a : node, b : node), not left (a, b), not right(a, b) => False

head (a : node, b : node), not child (a, b) => False

leftHeaded (a : node), right (a : node, b : node) => modifier (a, b)
rightHeaded (a : node), left (a : node, b : node) => modifier (a, b)

head (a : node, b : node), complement (b.type) => match (a.type, b.type.output)
head (a : node, b : node), modifier (a : node, c : node), complement (b.type) => match (a.type, b.type.input)

modifier (a : node, b : node), adjunct (b.type) => match (a.type, b.type.output)
head (a : node, b : node), modifier (a : node, c : node), adjunct (c.type) => match (a.type, b.type.input)

sentential (t : type) v nominal (t : type)
sentential (t : type), nominal (t : type) => False

full (t : type) v blank (t : type)
full (t : type), blank (t) => False

nodetype (t : type) v not nodetype (t)
nodetype (t : type), not nodetype (t) => False

leaftype (t : type) v not leaftype (t)
leaftype (t : type), not leaftype (t) => False

nodetype (t : type), leaftype (t) => False
full (t : type), not leaftype (t), not nodetype (t) => False

leaftype (t : type) => blank (t.output), blank (t.input)

match (s : type, t : type) v not match (s, t)
match (s : type, t : type), not match(s, t) => False

match (s : type, t : type) => match (t, s)

blank (t : type), blank (s : type) => match (t, s)
leaftype (t : type), leaftype (s : type), nominal (t), nominal (s) => match (t, s)
leaftype (t : type), leaftype (s : type), sentential (t), sentential (s) => match (t, s)
nodetype (t : type), nodetype (s: type), match (t.input, s.input), match(t.output, s.output) => match (t, s)

leaftype (t : type), leaftype (s : type), nominal (t), sentential (s) => not match (t, s)
blank (t : type), full (s : type) => not match(t, s)

blank (t : type) => blank (t.output), blank (t.input)
nodetype (t : type), blank (t.input) => False
nodetype (t : type), blank (t.output) => False
nodetype (t : type) => full (t.input)
nodetype (t : type) => full (t.output)

phrase(a : node) => full(a.type)
leaf(a: node) => full(a.type)

blank (a: type), nodetype (a) => False
blank (a: type), leaftype (a) => False
