sort node 30
sort type 30

-- Leaves vs phrases --

phrase(n : node) => expression(n)
leaf(n : node) => expression(n)

leaf(n : node) v phrase(n)
leaf(n : node), phrase(n) => False

complementation(n : node) => composition(n)
adjunction(n : node) => composition(n)
leaf(n : node), composition(n) => False

composition(n : node) v not a composition (n)
composition(n : node), not a composition (n) => False

phrase(n : node), not a composition (n) => False

-- Tree properties --

next(n : node, m: node) v not next(n : node, m : node)
next(n : node), not next (n : node, m : node) => False

before(n : node, m : node) v not before(n : node, m : node)
before(n : node, m : node), not before(n, m) => False

leaf(n : node), left(n, m : node) => False
leaf(n : node), right(n, m : node) => False

phrase(n : node), next(n : node, m: node) => left(n, m)

left(n : node, n) => False
right(n : node, n) => False

left(a: node, b : node), right(a, b) => False

left(n : node, m : node), before(m, n) => False
right(n : node, m : node), before(m, n) => False

left(n : node, m : node), not next(n, m) => False

left of (b : node, a : node), before(a, b) => False
left(a : node, b : node), right(a, c : node) => left of (b, c)
left of (a : node, b : node), left of (b : node, c : node) => left of (a, c)
left of(a : node, b : node), left of(b, a) => False

left(a : node, b : node), right(a, b) => False

right(a : node, b : node), right(c : node, b), a != c => False
right(a : node, b : node), left(c : node, b) => False
left(a : node, b : node), left(c : node, b), a != c => False


-- Syntactic composition rules and type rules --

-- composition --

phrase(n : node),
argumentor(n, m : node) =>
match(n.type, m.type.output)

expression(a : node),
argumentor(a, b : node),
argument(a, c : node),
not match (b.type.input, c.type) =>
False

match(a : type, b : type) => match(b, a)
not match(a : type, b : type) => not match (b, a)

-- types --

composite(t : type), blank(t.input) => False
composite(t : type), blank(t.output) => False
composite(t: type), blank(t) => False

sentence(t : type) v name(t) v composite(t)
simple(t : type), composite(t) => False

sentence(t : type)  => simple(t)
name(t : type) => simple(t)

match(t : type, s : type) v not match(t, s)
match(t : type, s : type), not match(t, s) => False

sentence(t : type),
name(s : type) =>
not match (t, s)

name(t : type),
name(s : type) =>
match (t, s)

sentence(t : type),
sentence(s : type) =>
match(t, s)

composite(t : type),
composite(s : type),
match(t.input, s.input),
match(t.output, s.output) =>
match(t, s)

composite(t : type),
composite(s : type),
not match(t.input, s.input) =>
not match(t, s)

composite(t: type),
composite(s: type),
match(t.output, s.output) =>
not match(t, s)

-- Semantic composition rules --

argument(n: node, m: node), adjunction(n) => bind(n.drs.self, m.drs.self)
argumentor(n : node, m: node), complementation(n) => bind(n.drs.self, m.drs.self)

-- Draft of DRS rules --

p : property (s : semitem), bind(s : semitem, t : semitem) => p(t)
r : relation (s: semitem, t : semiten), bind(s: semitem, u: semitem) => r(u, t)
r : relation (s: semitem, t : semiten), bind(t: semitem, u: semitem) => r(s, u)
