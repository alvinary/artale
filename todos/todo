X - Add 'distinct' macro
     X - Parser
     X - Solver interpretation (skipping assignment candidate tuples where
         variables marked as distinct are identical)
     X - Test with more complicated instances

- Add HornSolver.add_rule() method (which adds a rule and updates the two literal
  maps)

- Test programs with errors to find relevant cases for Parser.check()

X - Add negation macro (a or not a) and (a and not a => False)
   -> only necessary for some predicates and quick to write in a program.

X - Add equality macro (each constant is equal to itself and unequal to the rest. That makes
    the distinct macro reundant)

- Add order and equivalence operators to grammar

- Change the 'bodge' model enumaration strategy for something more complete or something complete

- Add parser for lexical items

- Define interpretation for 'sort' statements
  - sort name n
  - constant sort blah, blah, blah
  - tree name n_leaves
  
  X - read_sorts() is implemented but not tested
  - test it
  - add glue code
  
  (num name n) (tree name n) (const name ct_name) - por cada nombre ahi -

- Improve docstrings

- Testear exhaustivamente las funciones que ya están escritas

X - Dump tile properties to file

- Test a.f : fun

- Add könisberg bridge example

- agregar estructura de modulos decente

- agregarle al modelo algo para leer las sort parts que saca el parser
   X - Ta en el parser, no ta la interpretacion en models.py

- hacer que artale.py tenga artale.from_program() que parsee y aplique el pipeline bien

- agregar declaraciones de funciones

X- embedding de la negación

- Any macro
   X - draft
   X - test

X - El embedding de la negacion anda!!

- Usar un orden y una lista para contar cuantos elementos lexicos cubre cada
  diatesis:

  - Accepts(d1, e1), not in (e1, d1.list) => False
  - cons(e1, d.1list), not accepts(d1, e1) => False
  - before(e1, e2), above(e2, e1, list) => False (para romper la simetria esa)

- qué pasa si un... coso tiene dos any?
- en realidad todos los any son independientes no? total, tienen que ser todos los miembros de cada sort :)

- Add test suite with any macros

- When only functions of the sort over which a variable ranges are used, for some reason there is a bug:
  full(t : type), full(s : type), match(s.input, s.output) => macth(s, t) works, but
  match(s.input : type, t.input : type) => match(s, t) doesn't. Code up to now is super ad hoc
  and full of errors like this. 
  
X - Add a set of facts to HornSolver, so you can check if p(x) by checking running "p x" in HornSolver.positive_facts.
  Maybe getting the facts from a model is better, since true facts are a property of models, and not the solver
  itself.
  -> This is not useful, since models are small arrays which can be converted to sets very quickly with set(model)

- Complete symmetry breaking (adding constraints to which constants can be right of another)
   - These will be made worse with lexical items (if there can be W words right of a given node,
     then you have WR isomorphic trees, with W right of that node, in constants cn, cn+1, cn+2...c(r-n))

- Quantify over blocks of clauses
  
  a : A, b : A, c : C {
     p(a) => q(a)
     q(b, a), r(b, c) => s(b)
     t(a, c) => y(c, a)
  }

  That requires less typing and will make embeddings faster, I think (the same number of clauses are added, but
  all n clauses are created for each set of assignments, and you don't have to allocate and cycle through assignments n times)

  - Figure out how to deal with rules using only a subset of variables (i.e. don't add the same clause on a and c |b| times)
  - Write the parser

- There is more (and more serious) symmetry breaking to be done! Now there are types, and those have symmetries too
  (at least in trees without a lexicon - better fix that before trying anything else!)

- Add a keyword argument sort_restrictions to HornSolver.unfold_rule(), so you can
  unfold / embed a rule only for a subset of a sort (this is useful when
  a sort can be partitioned into several independent / mutually not related
  subsets, so that rules quantifying over the sort do not waste user time and memory
  on relations that have no bearing on relevant model properties)

- Closest feature match in map tagger

- Use quadratic CYK style tree embedding
